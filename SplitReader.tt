<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Text" #>
<#@ output extension=".cs" #>
<#
	var separators = new List<(string Type, bool Generic, string Test)>()
	{
		( Type: "char", Generic: false, Test: "letter == separator" ),
		( Type: "ICollection<char>", Generic: true, Test: "separator.Contains(letter)" ),
		( Type: "Predicate<char>", Generic: false, Test: "separator(letter)" ),
		( Type: "char[]", Generic: false, Test: "Contains(separator, letter)" ),
	};
	var valuesAdds = new List<(string Type, bool Generic, string Add)>()
	{
		( Type: "ICollection<string>", Generic: true, Add: "values.Add(value)" ),
		( Type: "Action<string>", Generic: false, Add: "values(value)" ),
	};
	bool line;
#>
using System;
using System.Collections.Generic;
using System.Text;

namespace Innovoft.IO
{
	partial class SplitReader
	{
		#region Methods
<#
	line = false;
#>
<#
	foreach (var separator in separators)
	{
		foreach (var values in valuesAdds)
		{
			if (line)
			{
#>

<#
			}
			else
			{
				line = true;
			}
			if (separator.Generic)
			{
				if (values.Generic)
				{
#>
		public bool ReadColumnsAdd<TSeparator, TValues>(TSeparator separator, TValues values)
			where TSeparator: <#= separator.Type #> where TValues: <#= values.Type #>
<#
				}
				else
				{
#>
		public bool ReadColumnsAdd<TSeparator>(TSeparator separator, <#= values.Type #> values)
			where TSeparator: <#= separator.Type #>
<#
				}
			}
			else
			{
				if (values.Generic)
				{
#>
		public bool ReadColumnsAdd<TValues>(<#= separator.Type #> separator, TValues values)
			where TValues: <#= values.Type #>
<#
				}
				else
				{
#>
		public bool ReadColumnsAdd(<#= separator.Type #> separator, <#= values.Type #> values)
<#
				}
			}
#>
		{
			if (stream == null)
			{
				throw new ObjectDisposedException(nameof(SplitReader));
			}
			if (lettersOffset >= lettersLength && !ReadBuffers())
			{
				return false;
			}
			var offset = lettersOffset;
			var building = false;
			while (true)
			{
				var letter = letters[lettersOffset];
				switch (letter)
				{
				case CR:
					if (building)
					{
						builder.Append(letters, offset, lettersOffset - offset);
						var value = builder.ToString();
						<#= values.Add #>;
						builder.Clear();
					}
					else
					{
						var value = new string(letters, offset, lettersOffset - offset);
						<#= values.Add #>;
					}
					++lettersOffset;
					//LF
					if (lettersOffset >= lettersLength)
					{
						if (!ReadBuffers())
						{
							return true;
						}
					}
					if (letters[lettersOffset] == LF)
					{
						++lettersOffset;
					}
					return true;

				case LF:
					if (building)
					{
						builder.Append(letters, offset, lettersOffset - offset);
						var value = builder.ToString();
						<#= values.Add #>;
						builder.Clear();
						++lettersOffset;
						return true;
					}
					else
					{
						var value = new string(letters, offset, lettersOffset - offset);
						<#= values.Add #>;
						++lettersOffset;
						return true;
					}

				default:
					if (<#= separator.Test #>)
					{
						if (building)
						{
							builder.Append(letters, offset, lettersOffset - offset);
							var value = builder.ToString();
							<#= values.Add #>;
							builder.Clear();
							building = false;
							offset = ++lettersOffset;
							break;
						}
						else
						{
							var value = new string(letters, offset, lettersOffset - offset);
							<#= values.Add #>;
							offset = ++lettersOffset;
							break;
						}
					}
					else
					{
						++lettersOffset;
					}
					break;
				}
				if (lettersOffset >= lettersLength)
				{
					if (offset <= lettersOffset)
					{
						builder.Append(letters, offset, lettersOffset - offset);
						building = true;
					}
					if (!ReadBuffers())
					{
						if (building)
						{
							var value = builder.ToString();
							<#= values.Add #>;
							builder.Clear();
						}
						return true;
					}
					offset = 0;
				}
			}
		}
<#
		}
	}
#>
<#
	foreach (var separator in separators)
	{
		if (line)
		{
#>

<#
		}
		else
		{
			line = true;
		}
		if (separator.Generic)
		{
#>
		public bool ReadColumn<TSeparator>(TSeparator separator, int column, out string value)
			where TSeparator: <#= separator.Type #>
<#
		}
		else
		{
#>
		public bool ReadColumn(<#= separator.Type #> separator, int column, out string value)
<#
		}
#>
		{
			if (stream == null)
			{
				throw new ObjectDisposedException(nameof(SplitReader));
			}
			if (lettersOffset >= lettersLength && !ReadBuffers())
			{
				value = null;
				return false;
			}
			var offset = lettersOffset;
			var building = false;
			string columnValue = null;
			while (true)
			{
				var letter = letters[lettersOffset];
				switch (letter)
				{
				case CR:
					if (column == 0)
					{
						if (building)
						{
							builder.Append(letters, offset, lettersOffset - offset);
							columnValue = builder.ToString();
							builder.Clear();
						}
						else
						{
							columnValue = new string(letters, offset, lettersOffset - offset);
						}
					}
					++lettersOffset;
					//LF
					if (lettersOffset >= lettersLength)
					{
						if (!ReadBuffers())
						{
							value = columnValue;
							return true;
						}
					}
					if (letters[lettersOffset] == LF)
					{
						++lettersOffset;
					}
					value = columnValue;
					return true;

				case LF:
					if (column == 0)
					{
						if (building)
						{
							builder.Append(letters, offset, lettersOffset - offset);
							columnValue = builder.ToString();
							builder.Clear();
							++lettersOffset;
							value = columnValue;
							return true;
						}
						else
						{
							columnValue = new string(letters, offset, lettersOffset - offset);
							++lettersOffset;
							value = columnValue;
							return true;
						}
					}
					else
					{
						++lettersOffset;
						value = columnValue;
						return true;
					}

				default:
					if (<#= separator.Test #>)
					{
						if (column == 0)
						{
							if (building)
							{
								builder.Append(letters, offset, lettersOffset - offset);
								columnValue = builder.ToString();
								builder.Clear();
								building = false;
								offset = ++lettersOffset;
								--column;
								break;
							}
							else
							{
								columnValue = new string(letters, offset, lettersOffset - offset);
								offset = ++lettersOffset;
								--column;
								break;
							}
						}
						else
						{
							offset = ++lettersOffset;
							--column;
							break;
						}
					}
					else
					{
						++lettersOffset;
					}
					break;
				}
				if (lettersOffset >= lettersLength)
				{
					if (column == 0)
					{
						if (offset <= lettersOffset)
						{
							builder.Append(letters, offset, lettersOffset - offset);
							building = true;
						}
					}
					if (!ReadBuffers())
					{
						if (building)
						{
							columnValue = builder.ToString();
							builder.Clear();
						}
						value = columnValue;
						return true;
					}
					offset = 0;
				}
			}
		}
<#
	}
#>
		#endregion //Methods
	}
}
